defmodule MatchmakingChallenge.Balancer do
  @spec split_into_buckets(list(map()), number()) :: list()
  def split_into_buckets(clubs, max_next_bucket_size) do
    # Time Complexity: O(n) where n is the number of clubs
    #   Shuffling: O(n)
    #   Distribution: O(n) - each club is processed once
    #   Formatting: O(n)
    # Space Complexity: O(n)
    #   Stream creates O(n) intermediate data structures
    #   Final result is O(n)
    #   No additional space for large datasets due to lazy evaluation
    clubs
    |> Enum.map(&take_id/1)
    |> Enum.shuffle()
    |> distribute_evenly(max_next_bucket_size)
    |> Enum.map(&format_bucket/1)
  end

  defp take_id(%{"club_id" => id}), do: %{id: id}
  defp take_id(%{"id" => id}), do: %{id: id}

  defp distribute_evenly(clubs, max_next_bucket_size) do
    clubs_count = length(clubs)

    # Total number of buckets needed for balanced distribution:
    # e.g., 10 clubs รท 4 max size = 3 buckets
    total_buckets_needed = ceil(clubs_count / max_next_bucket_size)

    # Emits a sequence of values for the given accumulator.
    # Successive values are generated by calling function with the previous accumulator
    # and it must return a tuple with the current value and next accumulator.
    # e.g., distribution: [4, 3, 3]
    Stream.unfold(clubs, &split_next_bucket(&1, clubs_count, total_buckets_needed))
  end

  # The enumeration finishes when it returns nil.
  defp split_next_bucket([], _total, _total_buckets_needed), do: nil

  defp split_next_bucket(remaining_clubs, clubs_count, total_buckets_needed) do
    remaining_clubs_count = length(remaining_clubs)

    # Number of clubs processed so far
    # e.g., 10 - 3 = 7 clubs
    clubs_processed = clubs_count - remaining_clubs_count
    # Number of buckets created so far
    # e.g., 7 * 3 รท 10 = 2 buckets
    buckets_created = div(clubs_processed * total_buckets_needed, clubs_count)
    # Number of buckets remaining
    # e.g., 3 - 2 = 1 bucket
    buckets_remaining = total_buckets_needed - buckets_created
    # Calculate size of the next balanced bucket
    # e.g., 3 clubs รท 1 bucket = 3 clubs
    next_bucket_size = ceil(remaining_clubs_count / buckets_remaining)

    Enum.split(remaining_clubs, next_bucket_size)
  end

  defp format_bucket(chunk), do: %{metadata: %{size: length(chunk)}, clubs: chunk}
end
